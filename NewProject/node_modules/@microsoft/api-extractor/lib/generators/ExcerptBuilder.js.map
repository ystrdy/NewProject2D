{"version":3,"file":"ExcerptBuilder.js","sourceRoot":"","sources":["../../src/generators/ExcerptBuilder.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,iCAAiC;AAOjC,2CAAwC;AA4DxC,MAAa,cAAc;IAClB,MAAM,CAAC,KAAK,CAAC,OAAiC;QACnD,MAAM,IAAI,GAAS,IAAI,WAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAElD,MAAM,iBAAiB,GAAqC,IAAI,GAAG,EAA+B,CAAC;QACnG,KAAK,MAAM,OAAO,IAAI,OAAO,CAAC,cAAc,IAAI,EAAE,EAAE;YAClD,IAAI,OAAO,CAAC,IAAI,EAAE;gBAChB,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;aACzD;SACF;QAED,MAAM,aAAa,GAAoB,EAAE,CAAC;QAE1C,cAAc,CAAC,UAAU,CAAC,aAAa,EAAE,IAAI,EAAE;YAC7C,YAAY,EAAE,OAAO,CAAC,YAAY;YAClC,mBAAmB,EAAE,OAAO,CAAC,mBAAmB;YAChD,iBAAiB;YACjB,0BAA0B,EAAE,KAAK;SAClC,CAAC,CAAC;QAEH,OAAO,aAAa,CAAC;IACvB,CAAC;IAEM,MAAM,CAAC,qBAAqB;QACjC,OAAO,EAAE,UAAU,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC;IACxC,CAAC;IAEO,MAAM,CAAC,UAAU,CAAC,aAA8B,EAAE,IAAU,EAAE,KAAsB;QAC1F,IAAI,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,YAAY,EAAE;YAC5C,uBAAuB;YACvB,OAAO,IAAI,CAAC;SACb;QAED,iCAAiC;QACjC,MAAM,kBAAkB,GAAmC,KAAK,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAClG,IAAI,iBAAiB,GAAW,CAAC,CAAC;QAElC,IAAI,kBAAkB,EAAE;YACtB,gGAAgG;YAChG,iBAAiB,GAAG,aAAa,CAAC,MAAM,CAAC;YACzC,KAAK,CAAC,0BAA0B,GAAG,IAAI,CAAC;SACzC;QAED,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE;gBAC1C,cAAc,CAAC,YAAY,CAAC,aAAa,+BACvC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;aACvB;iBAAM;gBACL,cAAc,CAAC,YAAY,CAAC,aAAa,2BACvC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;aACvB;SACF;QAED,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,YAAY,EAAE;gBACpC,IAAI,KAAK,CAAC,mBAAmB,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,mBAAmB,EAAE;oBACzE,+EAA+E;oBAC/E,OAAO,KAAK,CAAC;iBACd;aACF;YAED,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE;gBACjD,OAAO,KAAK,CAAC;aACd;SACF;QAED,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,cAAc,CAAC,YAAY,CAAC,aAAa,2BAA4B,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;SAC1F;QACD,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,cAAc,CAAC,YAAY,CAAC,aAAa,2BAA4B,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;SAC7F;QAED,mDAAmD;QACnD,IAAI,kBAAkB,EAAE;YACtB,kBAAkB,CAAC,UAAU,GAAG,iBAAiB,CAAC;YAElD,6GAA6G;YAC7G,kBAAkB,CAAC,QAAQ,GAAG,aAAa,CAAC,MAAM,CAAC;YAEnD,KAAK,CAAC,0BAA0B,GAAG,IAAI,CAAC;SACzC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,MAAM,CAAC,YAAY,CAAC,aAA8B,EAAE,gBAAkC,EAC5F,IAAY,EAAE,KAAsB;QAEpC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;YACrB,OAAO;SACR;QAED,IAAI,gBAAgB,4BAA6B,EAAE;YACjD,aAAa,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC;YAC1D,KAAK,CAAC,0BAA0B,GAAG,KAAK,CAAC;SAE1C;aAAM;YACL,sEAAsE;YACtE,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,0BAA0B,EAAE;gBACjE,mDAAmD;gBACnD,MAAM,aAAa,GAAkB,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC7E,IAAI,aAAa,CAAC,IAAI,KAAK,gBAAgB,EAAE;oBAC3C,aAAa,CAAC,IAAI,IAAI,IAAI,CAAC;oBAC3B,OAAO;iBACR;aACF;YAED,aAAa,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC;YAC1D,KAAK,CAAC,0BAA0B,GAAG,KAAK,CAAC;SAC1C;IACH,CAAC;CAEF;AAjHD,wCAiHC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport {\r\n  ExcerptTokenKind,\r\n  IExcerptToken,\r\n  IExcerptTokenRange\r\n} from '@microsoft/api-extractor-model';\r\n\r\nimport { Span } from '../analyzer/Span';\r\n\r\n/**\r\n * Used to provide ExcerptBuilder with a list of nodes whose token range we want to capture.\r\n */\r\nexport interface IExcerptBuilderNodeToCapture {\r\n  /**\r\n   * The node to capture\r\n   */\r\n  node: ts.Node | undefined;\r\n  /**\r\n   * The token range whose startIndex/endIndex will be overwritten with the indexes for the\r\n   * tokens corresponding to IExcerptBuilderNodeToCapture.node\r\n   */\r\n  tokenRange: IExcerptTokenRange;\r\n}\r\n\r\n/**\r\n * Options for ExcerptBuilder\r\n */\r\nexport interface ISignatureBuilderOptions {\r\n  /**\r\n   * The AST node that we will traverse to extract tokens\r\n   */\r\n  startingNode: ts.Node;\r\n\r\n  /**\r\n   * Normally, the excerpt will include all child nodes for `startingNode`; whereas if `childKindToStopBefore`\r\n   * is specified, then the node traversal will stop before (i.e. excluding) the first immediate child\r\n   * of `startingNode` with the specified syntax kind.\r\n   *\r\n   * @remarks\r\n   * For example, suppose the signature is `interface X: Y { z: string }`.  The token `{` has syntax kind\r\n   * `ts.SyntaxKind.FirstPunctuation`, so we can specify that to truncate the excerpt to `interface X: Y`.\r\n   */\r\n  stopBeforeChildKind?: ts.SyntaxKind;\r\n\r\n  /**\r\n   * A list of child nodes whose token ranges we want to capture\r\n   */\r\n  nodesToCapture?: IExcerptBuilderNodeToCapture[];\r\n}\r\n\r\n/**\r\n * Internal state for ExcerptBuilder\r\n */\r\ninterface IBuildSpanState {\r\n  startingNode: ts.Node;\r\n  stopBeforeChildKind: ts.SyntaxKind | undefined;\r\n\r\n  tokenRangesByNode: Map<ts.Node, IExcerptTokenRange>;\r\n\r\n  /**\r\n   * Normally adjacent tokens of the same kind get merged, to avoid creating lots of unnecessary extra tokens.\r\n   * However when an captured excerpt needs to start/end at a specific character, we temporarily disable merging by\r\n   * setting this flag.  After the new token is added, this flag is cleared.\r\n   */\r\n  disableMergingForNextToken: boolean;\r\n}\r\n\r\nexport class ExcerptBuilder {\r\n  public static build(options: ISignatureBuilderOptions): IExcerptToken[] {\r\n    const span: Span = new Span(options.startingNode);\r\n\r\n    const tokenRangesByNode: Map<ts.Node, IExcerptTokenRange> = new Map<ts.Node, IExcerptTokenRange>();\r\n    for (const excerpt of options.nodesToCapture || []) {\r\n      if (excerpt.node) {\r\n        tokenRangesByNode.set(excerpt.node, excerpt.tokenRange);\r\n      }\r\n    }\r\n\r\n    const excerptTokens: IExcerptToken[] = [];\r\n\r\n    ExcerptBuilder._buildSpan(excerptTokens, span, {\r\n      startingNode: options.startingNode,\r\n      stopBeforeChildKind: options.stopBeforeChildKind,\r\n      tokenRangesByNode,\r\n      disableMergingForNextToken: false\r\n    });\r\n\r\n    return excerptTokens;\r\n  }\r\n\r\n  public static createEmptyTokenRange(): IExcerptTokenRange {\r\n    return { startIndex: 0, endIndex: 0 };\r\n  }\r\n\r\n  private static _buildSpan(excerptTokens: IExcerptToken[], span: Span, state: IBuildSpanState): boolean {\r\n    if (span.kind === ts.SyntaxKind.JSDocComment) {\r\n      // Discard any comments\r\n      return true;\r\n    }\r\n\r\n    // Can this node start a excerpt?\r\n    const capturedTokenRange: IExcerptTokenRange | undefined = state.tokenRangesByNode.get(span.node);\r\n    let excerptStartIndex: number = 0;\r\n\r\n    if (capturedTokenRange) {\r\n      // We will assign capturedTokenRange.startIndex to be the index of the next token to be appended\r\n      excerptStartIndex = excerptTokens.length;\r\n      state.disableMergingForNextToken = true;\r\n    }\r\n\r\n    if (span.prefix) {\r\n      if (span.kind === ts.SyntaxKind.Identifier) {\r\n        ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Reference,\r\n          span.prefix, state);\r\n      } else {\r\n        ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content,\r\n          span.prefix, state);\r\n      }\r\n    }\r\n\r\n    for (const child of span.children) {\r\n      if (span.node === state.startingNode) {\r\n        if (state.stopBeforeChildKind && child.kind === state.stopBeforeChildKind) {\r\n          // We reached the a child whose kind is stopBeforeChildKind, so stop traversing\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!this._buildSpan(excerptTokens, child, state)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (span.suffix) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.suffix, state);\r\n    }\r\n    if (span.separator) {\r\n      ExcerptBuilder._appendToken(excerptTokens, ExcerptTokenKind.Content, span.separator, state);\r\n    }\r\n\r\n    // Are we building a excerpt?  If so, set its range\r\n    if (capturedTokenRange) {\r\n      capturedTokenRange.startIndex = excerptStartIndex;\r\n\r\n      // We will assign capturedTokenRange.startIndex to be the index after the last token that was appended so far\r\n      capturedTokenRange.endIndex = excerptTokens.length;\r\n\r\n      state.disableMergingForNextToken = true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private static _appendToken(excerptTokens: IExcerptToken[], excerptTokenKind: ExcerptTokenKind,\r\n    text: string, state: IBuildSpanState): void {\r\n\r\n    if (text.length === 0) {\r\n      return;\r\n    }\r\n\r\n    if (excerptTokenKind !== ExcerptTokenKind.Content) {\r\n      excerptTokens.push({ kind: excerptTokenKind, text: text});\r\n      state.disableMergingForNextToken = false;\r\n\r\n    } else {\r\n      // If someone referenced this index, then we need to start a new token\r\n      if (excerptTokens.length > 0 && !state.disableMergingForNextToken) {\r\n        // Otherwise, can we merge with the previous token?\r\n        const previousToken: IExcerptToken = excerptTokens[excerptTokens.length - 1];\r\n        if (previousToken.kind === excerptTokenKind) {\r\n          previousToken.text += text;\r\n          return;\r\n        }\r\n      }\r\n\r\n      excerptTokens.push({ kind: excerptTokenKind, text: text});\r\n      state.disableMergingForNextToken = false;\r\n    }\r\n  }\r\n\r\n}\r\n"]}