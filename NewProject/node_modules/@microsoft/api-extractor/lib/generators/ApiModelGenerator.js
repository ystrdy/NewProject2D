"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-bitwise
const ts = require("typescript");
const api_extractor_model_1 = require("@microsoft/api-extractor-model");
const ExcerptBuilder_1 = require("./ExcerptBuilder");
const AstSymbol_1 = require("../analyzer/AstSymbol");
class ApiModelGenerator {
    constructor(collector) {
        this._collector = collector;
        this._cachedOverloadIndexesByDeclaration = new Map();
        this._apiModel = new api_extractor_model_1.ApiModel();
    }
    get apiModel() {
        return this._apiModel;
    }
    buildApiPackage() {
        const packageDocComment = this._collector.workingPackage.tsdocComment;
        const apiPackage = new api_extractor_model_1.ApiPackage({
            name: this._collector.workingPackage.name,
            docComment: packageDocComment
        });
        this._apiModel.addMember(apiPackage);
        const apiEntryPoint = new api_extractor_model_1.ApiEntryPoint({ name: '' });
        apiPackage.addMember(apiEntryPoint);
        // Create a CollectorEntity for each top-level export
        for (const entity of this._collector.entities) {
            if (entity.exported) {
                if (entity.astEntity instanceof AstSymbol_1.AstSymbol) {
                    for (const astDeclaration of entity.astEntity.astDeclarations) {
                        this._processDeclaration(astDeclaration, entity.nameForEmit, apiEntryPoint);
                    }
                }
                else {
                    // TODO: Figure out how to represent reexported AstImport objects.  Basically we need to introduce a new
                    // ApiItem subclass for "export alias", similar to a type alias, but representing declarations of the
                    // form "export { X } from 'external-package'".  We can also use this to solve GitHub issue #950.
                }
            }
        }
        return apiPackage;
    }
    _processDeclaration(astDeclaration, exportedName, parentApiItem) {
        if ((astDeclaration.modifierFlags & ts.ModifierFlags.Private) !== 0) {
            return; // trim out private declarations
        }
        const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
        if (releaseTag === api_extractor_model_1.ReleaseTag.Internal || releaseTag === api_extractor_model_1.ReleaseTag.Alpha) {
            return; // trim out items marked as "@internal" or "@alpha"
        }
        switch (astDeclaration.declaration.kind) {
            case ts.SyntaxKind.CallSignature:
                this._processApiCallSignature(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.Constructor:
                this._processApiConstructor(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.ConstructSignature:
                this._processApiConstructSignature(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.ClassDeclaration:
                this._processApiClass(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.EnumDeclaration:
                this._processApiEnum(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.EnumMember:
                this._processApiEnumMember(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.FunctionDeclaration:
                this._processApiFunction(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.IndexSignature:
                this._processApiIndexSignature(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.InterfaceDeclaration:
                this._processApiInterface(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.MethodDeclaration:
                this._processApiMethod(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.MethodSignature:
                this._processApiMethodSignature(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.ModuleDeclaration:
                this._processApiNamespace(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.PropertyDeclaration:
                this._processApiProperty(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.PropertySignature:
                this._processApiPropertySignature(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.TypeAliasDeclaration:
                this._processApiTypeAlias(astDeclaration, exportedName, parentApiItem);
                break;
            case ts.SyntaxKind.VariableDeclaration:
                this._processApiVariable(astDeclaration, exportedName, parentApiItem);
                break;
            default:
            // ignore unknown types
        }
    }
    _processChildDeclarations(astDeclaration, exportedName, parentApiItem) {
        for (const childDeclaration of astDeclaration.children) {
            this._processDeclaration(childDeclaration, undefined, parentApiItem);
        }
    }
    _processApiCallSignature(astDeclaration, exportedName, parentApiItem) {
        const overloadIndex = this._getOverloadIndex(astDeclaration);
        const canonicalReference = api_extractor_model_1.ApiCallSignature.getCanonicalReference(overloadIndex);
        let apiCallSignature = parentApiItem.tryGetMember(canonicalReference);
        if (apiCallSignature === undefined) {
            const callSignature = astDeclaration.declaration;
            const nodesToCapture = [];
            const returnTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: callSignature.type, tokenRange: returnTypeTokenRange });
            const typeParameters = this._captureTypeParameters(nodesToCapture, callSignature.typeParameters);
            const parameters = this._captureParameters(nodesToCapture, callSignature.parameters);
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiCallSignature = new api_extractor_model_1.ApiCallSignature({ docComment, releaseTag, typeParameters, parameters, overloadIndex,
                excerptTokens, returnTypeTokenRange });
            parentApiItem.addMember(apiCallSignature);
        }
    }
    _processApiConstructor(astDeclaration, exportedName, parentApiItem) {
        const overloadIndex = this._getOverloadIndex(astDeclaration);
        const canonicalReference = api_extractor_model_1.ApiConstructor.getCanonicalReference(overloadIndex);
        let apiConstructor = parentApiItem.tryGetMember(canonicalReference);
        if (apiConstructor === undefined) {
            const constructorDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const parameters = this._captureParameters(nodesToCapture, constructorDeclaration.parameters);
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiConstructor = new api_extractor_model_1.ApiConstructor({ docComment, releaseTag, parameters, overloadIndex,
                excerptTokens });
            parentApiItem.addMember(apiConstructor);
        }
    }
    _processApiClass(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiClass.getCanonicalReference(name);
        let apiClass = parentApiItem.tryGetMember(canonicalReference);
        if (apiClass === undefined) {
            const classDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const typeParameters = this._captureTypeParameters(nodesToCapture, classDeclaration.typeParameters);
            let extendsTokenRange = undefined;
            const implementsTokenRanges = [];
            for (const heritageClause of classDeclaration.heritageClauses || []) {
                if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
                    extendsTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
                    if (heritageClause.types.length > 0) {
                        nodesToCapture.push({ node: heritageClause.types[0], tokenRange: extendsTokenRange });
                    }
                }
                else if (heritageClause.token === ts.SyntaxKind.ImplementsKeyword) {
                    for (const heritageType of heritageClause.types) {
                        const implementsTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
                        implementsTokenRanges.push(implementsTokenRange);
                        nodesToCapture.push({ node: heritageType, tokenRange: implementsTokenRange });
                    }
                }
            }
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                stopBeforeChildKind: ts.SyntaxKind.FirstPunctuation,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiClass = new api_extractor_model_1.ApiClass({ name, docComment, releaseTag, excerptTokens, typeParameters, extendsTokenRange,
                implementsTokenRanges });
            parentApiItem.addMember(apiClass);
        }
        this._processChildDeclarations(astDeclaration, exportedName, apiClass);
    }
    _processApiConstructSignature(astDeclaration, exportedName, parentApiItem) {
        const overloadIndex = this._getOverloadIndex(astDeclaration);
        const canonicalReference = api_extractor_model_1.ApiConstructSignature.getCanonicalReference(overloadIndex);
        let apiConstructSignature = parentApiItem.tryGetMember(canonicalReference);
        if (apiConstructSignature === undefined) {
            const constructSignature = astDeclaration.declaration;
            const nodesToCapture = [];
            const returnTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: constructSignature.type, tokenRange: returnTypeTokenRange });
            const typeParameters = this._captureTypeParameters(nodesToCapture, constructSignature.typeParameters);
            const parameters = this._captureParameters(nodesToCapture, constructSignature.parameters);
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiConstructSignature = new api_extractor_model_1.ApiConstructSignature({ docComment, releaseTag, typeParameters, parameters,
                overloadIndex, excerptTokens, returnTypeTokenRange });
            parentApiItem.addMember(apiConstructSignature);
        }
    }
    _processApiEnum(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiEnum.getCanonicalReference(name);
        let apiEnum = parentApiItem.tryGetMember(canonicalReference);
        if (apiEnum === undefined) {
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                stopBeforeChildKind: ts.SyntaxKind.FirstPunctuation // FirstPunctuation = "{"
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiEnum = new api_extractor_model_1.ApiEnum({ name, docComment, releaseTag, excerptTokens });
            parentApiItem.addMember(apiEnum);
        }
        this._processChildDeclarations(astDeclaration, exportedName, apiEnum);
    }
    _processApiEnumMember(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiEnumMember.getCanonicalReference(name);
        let apiEnumMember = parentApiItem.tryGetMember(canonicalReference);
        if (apiEnumMember === undefined) {
            const enumMember = astDeclaration.declaration;
            const nodesToCapture = [];
            const initializerTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: enumMember.initializer, tokenRange: initializerTokenRange });
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiEnumMember = new api_extractor_model_1.ApiEnumMember({ name, docComment, releaseTag,
                excerptTokens, initializerTokenRange });
            parentApiItem.addMember(apiEnumMember);
        }
    }
    _processApiFunction(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const overloadIndex = this._getOverloadIndex(astDeclaration);
        const canonicalReference = api_extractor_model_1.ApiFunction.getCanonicalReference(name, overloadIndex);
        let apiFunction = parentApiItem.tryGetMember(canonicalReference);
        if (apiFunction === undefined) {
            const functionDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const returnTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: functionDeclaration.type, tokenRange: returnTypeTokenRange });
            const typeParameters = this._captureTypeParameters(nodesToCapture, functionDeclaration.typeParameters);
            const parameters = this._captureParameters(nodesToCapture, functionDeclaration.parameters);
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiFunction = new api_extractor_model_1.ApiFunction({ name, docComment, releaseTag, typeParameters, parameters, overloadIndex,
                excerptTokens, returnTypeTokenRange });
            parentApiItem.addMember(apiFunction);
        }
    }
    _processApiIndexSignature(astDeclaration, exportedName, parentApiItem) {
        const overloadIndex = this._getOverloadIndex(astDeclaration);
        const canonicalReference = api_extractor_model_1.ApiIndexSignature.getCanonicalReference(overloadIndex);
        let apiIndexSignature = parentApiItem.tryGetMember(canonicalReference);
        if (apiIndexSignature === undefined) {
            const indexSignature = astDeclaration.declaration;
            const nodesToCapture = [];
            const returnTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: indexSignature.type, tokenRange: returnTypeTokenRange });
            const parameters = this._captureParameters(nodesToCapture, indexSignature.parameters);
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiIndexSignature = new api_extractor_model_1.ApiIndexSignature({ docComment, releaseTag, parameters, overloadIndex,
                excerptTokens, returnTypeTokenRange });
            parentApiItem.addMember(apiIndexSignature);
        }
    }
    _processApiInterface(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiInterface.getCanonicalReference(name);
        let apiInterface = parentApiItem.tryGetMember(canonicalReference);
        if (apiInterface === undefined) {
            const interfaceDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const typeParameters = this._captureTypeParameters(nodesToCapture, interfaceDeclaration.typeParameters);
            const extendsTokenRanges = [];
            for (const heritageClause of interfaceDeclaration.heritageClauses || []) {
                if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {
                    for (const heritageType of heritageClause.types) {
                        const extendsTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
                        extendsTokenRanges.push(extendsTokenRange);
                        nodesToCapture.push({ node: heritageType, tokenRange: extendsTokenRange });
                    }
                }
            }
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                stopBeforeChildKind: ts.SyntaxKind.FirstPunctuation,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiInterface = new api_extractor_model_1.ApiInterface({ name, docComment, releaseTag, excerptTokens, typeParameters,
                extendsTokenRanges });
            parentApiItem.addMember(apiInterface);
        }
        this._processChildDeclarations(astDeclaration, exportedName, apiInterface);
    }
    _processApiMethod(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const isStatic = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;
        const overloadIndex = this._getOverloadIndex(astDeclaration);
        const canonicalReference = api_extractor_model_1.ApiMethod.getCanonicalReference(name, isStatic, overloadIndex);
        let apiMethod = parentApiItem.tryGetMember(canonicalReference);
        if (apiMethod === undefined) {
            const methodDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const returnTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: methodDeclaration.type, tokenRange: returnTypeTokenRange });
            const typeParameters = this._captureTypeParameters(nodesToCapture, methodDeclaration.typeParameters);
            const parameters = this._captureParameters(nodesToCapture, methodDeclaration.parameters);
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiMethod = new api_extractor_model_1.ApiMethod({ name, docComment, releaseTag, isStatic, typeParameters, parameters, overloadIndex,
                excerptTokens, returnTypeTokenRange });
            parentApiItem.addMember(apiMethod);
        }
    }
    _processApiMethodSignature(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const overloadIndex = this._getOverloadIndex(astDeclaration);
        const canonicalReference = api_extractor_model_1.ApiMethodSignature.getCanonicalReference(name, overloadIndex);
        let apiMethodSignature = parentApiItem.tryGetMember(canonicalReference);
        if (apiMethodSignature === undefined) {
            const methodSignature = astDeclaration.declaration;
            const nodesToCapture = [];
            const returnTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: methodSignature.type, tokenRange: returnTypeTokenRange });
            const typeParameters = this._captureTypeParameters(nodesToCapture, methodSignature.typeParameters);
            const parameters = this._captureParameters(nodesToCapture, methodSignature.parameters);
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiMethodSignature = new api_extractor_model_1.ApiMethodSignature({ name, docComment, releaseTag, typeParameters, parameters,
                overloadIndex, excerptTokens, returnTypeTokenRange });
            parentApiItem.addMember(apiMethodSignature);
        }
    }
    _processApiNamespace(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiNamespace.getCanonicalReference(name);
        let apiNamespace = parentApiItem.tryGetMember(canonicalReference);
        if (apiNamespace === undefined) {
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                stopBeforeChildKind: ts.SyntaxKind.ModuleBlock // ModuleBlock = the "{ ... }" block
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiNamespace = new api_extractor_model_1.ApiNamespace({ name, docComment, releaseTag, excerptTokens });
            parentApiItem.addMember(apiNamespace);
        }
        this._processChildDeclarations(astDeclaration, exportedName, apiNamespace);
    }
    _processApiProperty(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const isStatic = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;
        const canonicalReference = api_extractor_model_1.ApiProperty.getCanonicalReference(name, isStatic);
        let apiProperty = parentApiItem.tryGetMember(canonicalReference);
        if (apiProperty === undefined) {
            const propertyDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const propertyTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: propertyDeclaration.type, tokenRange: propertyTypeTokenRange });
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiProperty = new api_extractor_model_1.ApiProperty({ name, docComment, releaseTag, isStatic, excerptTokens, propertyTypeTokenRange });
            parentApiItem.addMember(apiProperty);
        }
        else {
            // If the property was already declared before (via a merged interface declaration),
            // we assume its signature is identical, because the language requires that.
        }
    }
    _processApiPropertySignature(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiPropertySignature.getCanonicalReference(name);
        let apiPropertySignature = parentApiItem.tryGetMember(canonicalReference);
        if (apiPropertySignature === undefined) {
            const propertySignature = astDeclaration.declaration;
            const nodesToCapture = [];
            const propertyTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: propertySignature.type, tokenRange: propertyTypeTokenRange });
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiPropertySignature = new api_extractor_model_1.ApiPropertySignature({ name, docComment, releaseTag,
                excerptTokens, propertyTypeTokenRange });
            parentApiItem.addMember(apiPropertySignature);
        }
        else {
            // If the property was already declared before (via a merged interface declaration),
            // we assume its signature is identical, because the language requires that.
        }
    }
    _processApiTypeAlias(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiTypeAlias.getCanonicalReference(name);
        let apiTypeAlias = parentApiItem.tryGetMember(canonicalReference);
        if (apiTypeAlias === undefined) {
            const typeAliasDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const typeParameters = this._captureTypeParameters(nodesToCapture, typeAliasDeclaration.typeParameters);
            const typeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: typeAliasDeclaration.type, tokenRange: typeTokenRange });
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiTypeAlias = new api_extractor_model_1.ApiTypeAlias({ name, docComment, typeParameters, releaseTag, excerptTokens,
                typeTokenRange });
            parentApiItem.addMember(apiTypeAlias);
        }
    }
    _processApiVariable(astDeclaration, exportedName, parentApiItem) {
        const name = !!exportedName ? exportedName : astDeclaration.astSymbol.localName;
        const canonicalReference = api_extractor_model_1.ApiVariable.getCanonicalReference(name);
        let apiVariable = parentApiItem.tryGetMember(canonicalReference);
        if (apiVariable === undefined) {
            const variableDeclaration = astDeclaration.declaration;
            const nodesToCapture = [];
            const variableTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: variableDeclaration.type, tokenRange: variableTypeTokenRange });
            const excerptTokens = ExcerptBuilder_1.ExcerptBuilder.build({
                startingNode: astDeclaration.declaration,
                nodesToCapture
            });
            const docComment = this._collector.fetchMetadata(astDeclaration).tsdocComment;
            const releaseTag = this._collector.fetchMetadata(astDeclaration.astSymbol).releaseTag;
            apiVariable = new api_extractor_model_1.ApiVariable({ name, docComment, releaseTag, excerptTokens, variableTypeTokenRange });
            parentApiItem.addMember(apiVariable);
        }
    }
    _captureTypeParameters(nodesToCapture, typeParameterNodes) {
        const typeParameters = [];
        if (typeParameterNodes) {
            for (const typeParameter of typeParameterNodes) {
                const constraintTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
                nodesToCapture.push({ node: typeParameter.constraint, tokenRange: constraintTokenRange });
                const defaultTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
                nodesToCapture.push({ node: typeParameter.default, tokenRange: defaultTypeTokenRange });
                typeParameters.push({
                    typeParameterName: typeParameter.name.getText().trim(),
                    constraintTokenRange,
                    defaultTypeTokenRange
                });
            }
        }
        return typeParameters;
    }
    _captureParameters(nodesToCapture, parameterNodes) {
        const parameters = [];
        for (const parameter of parameterNodes) {
            const parameterTypeTokenRange = ExcerptBuilder_1.ExcerptBuilder.createEmptyTokenRange();
            nodesToCapture.push({ node: parameter.type, tokenRange: parameterTypeTokenRange });
            parameters.push({
                parameterName: parameter.name.getText().trim(),
                parameterTypeTokenRange
            });
        }
        return parameters;
    }
    _getOverloadIndex(astDeclaration) {
        const allDeclarations = astDeclaration.astSymbol.astDeclarations;
        if (allDeclarations.length === 1) {
            return 0; // trivial case
        }
        let overloadIndex = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);
        if (overloadIndex === undefined) {
            // TSDoc index selectors are positive integers counting from 1
            let nextIndex = 1;
            for (const other of allDeclarations) {
                // Filter out other declarations that are not overloads.  For example, an overloaded function can also
                // be a namespace.
                if (other.declaration.kind === astDeclaration.declaration.kind) {
                    this._cachedOverloadIndexesByDeclaration.set(other, nextIndex);
                    ++nextIndex;
                }
            }
            overloadIndex = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);
        }
        if (overloadIndex === undefined) {
            // This should never happen
            throw new Error('Error calculating overload index for declaration');
        }
        return overloadIndex;
    }
}
exports.ApiModelGenerator = ApiModelGenerator;
//# sourceMappingURL=ApiModelGenerator.js.map