"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ApiParameterListMixin_1 = require("../mixins/ApiParameterListMixin");
/**
 * PRIVATE
 * Allows ApiItemContainerMixin to assign the parent.
 */
// tslint:disable-next-line:variable-name
exports.ApiItem_parent = Symbol('ApiItem._parent');
/**
 * The abstract base class for all members of an `ApiModel` object.
 *
 * @remarks
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 * @public
 */
class ApiItem {
    constructor(options) {
        // ("options" is not used here, but part of the inheritance pattern)
    }
    static deserialize(jsonObject, context) {
        // The Deserializer class is coupled with a ton of other classes, so  we delay loading it
        // to avoid ES5 circular imports.
        const deserializerModule = require('../model/Deserializer');
        return deserializerModule.Deserializer.deserialize(context, jsonObject);
    }
    /** @virtual */
    static onDeserializeInto(options, context, jsonObject) {
        // (implemented by subclasses)
    }
    /** @virtual */
    serializeInto(jsonObject) {
        jsonObject.kind = this.kind;
        jsonObject.canonicalReference = this.canonicalReference;
    }
    /** @virtual */
    get kind() {
        throw new Error('ApiItem.kind was not implemented by the child class');
    }
    /** @virtual */
    get canonicalReference() {
        throw new Error('ApiItem.canonicalReference was not implemented by the child class');
    }
    /**
     * Returns a name for this object that can be used in diagnostic messages, for example.
     *
     * @remarks
     * For an object that inherits ApiNameMixin, this will return the declared name (e.g. the name of a TypeScript
     * function).  Otherwise, it will return a string such as "(call signature)" or "(model)".
     *
     * @virtual
     */
    get displayName() {
        switch (this.kind) {
            case "CallSignature" /* CallSignature */: return '(call)';
            case "Constructor" /* Constructor */: return '(constructor)';
            case "ConstructSignature" /* ConstructSignature */: return '(new)';
            case "IndexSignature" /* IndexSignature */: return '(indexer)';
            case "Model" /* Model */: return '(model)';
        }
        return '(???)'; // All other types should inherit ApiNameMixin which will override this property
    }
    /**
     * If this item was added to a ApiItemContainerMixin item, then this returns the container item.
     * If this is an Parameter that was added to a method or function, then this returns the function item.
     * Otherwise, it returns undefined.
     * @virtual
     */
    get parent() {
        return this[exports.ApiItem_parent];
    }
    /**
     * This property supports a visitor pattern for walking the tree.
     * For items with ApiItemContainerMixin, it returns the contained items.
     * Otherwise it returns an empty array.
     * @virtual
     */
    get members() {
        return [];
    }
    /**
     * Returns the chain of ancestors, starting from the root of the tree, and ending with the this item.
     */
    getHierarchy() {
        const hierarchy = [];
        for (let current = this; current !== undefined; current = current.parent) {
            hierarchy.push(current);
        }
        hierarchy.reverse();
        return hierarchy;
    }
    /**
     * This returns a scoped name such as `"Namespace1.Namespace2.MyClass.myMember()"`.  It does not include the
     * package name or entry point.
     *
     * @remarks
     * If called on an ApiEntrypoint, ApiPackage, or ApiModel item, the result is an empty string.
     */
    getScopedNameWithinPackage() {
        const reversedParts = [];
        for (let current = this; current !== undefined; current = current.parent) {
            if (current.kind === "Model" /* Model */
                || current.kind === "Package" /* Package */
                || current.kind === "EntryPoint" /* EntryPoint */) {
                break;
            }
            if (reversedParts.length !== 0) {
                reversedParts.push('.');
            }
            else {
                switch (current.kind) {
                    case "CallSignature" /* CallSignature */:
                    case "ConstructSignature" /* ConstructSignature */:
                    case "Constructor" /* Constructor */:
                    case "IndexSignature" /* IndexSignature */:
                        // These functional forms don't have a proper name, so we don't append the "()" suffix
                        break;
                    default:
                        if (ApiParameterListMixin_1.ApiParameterListMixin.isBaseClassOf(current)) { // tslint:disable-line:no-use-before-declare
                            reversedParts.push('()');
                        }
                }
            }
            reversedParts.push(current.displayName);
        }
        return reversedParts.reverse().join('');
    }
    /**
     * If this item is an ApiPackage or has an ApiPackage as one of its parents, then that object is returned.
     * Otherwise undefined is returned.
     */
    getAssociatedPackage() {
        for (let current = this; current !== undefined; current = current.parent) {
            if (current.kind === "Package" /* Package */) {
                return current;
            }
        }
        return undefined;
    }
    /** @virtual */
    getSortKey() {
        return this.canonicalReference;
    }
}
exports.ApiItem = ApiItem;
//# sourceMappingURL=ApiItem.js.map