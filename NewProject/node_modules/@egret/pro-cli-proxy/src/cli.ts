import args from 'args';
import path from 'path';
import lib = require('./index');
args
    .option('name', 'engine name')
    .option('path', 'engine path')
    .command('set', 'set engine name and path', (command, sub, options: any) => {
        const { name, path } = options;
        lib.setEngineRoot(name, path);

    });

args
    .option('name', 'engine name')
    .command('get', 'get engine path by name', (command, sub, options) => {
        console.log(command, sub, options);
    });

const sub = process.argv.concat().splice(3);
const projectRoot = parseProjectRoot(sub);
lib.init(projectRoot);
const EgretCompiler = lib.getCompiler().EgretCompiler;
const optionsConfig = EgretCompiler.getOptionsConfig();
for (const methodConfig of optionsConfig) {

    let a: typeof import('args') = args;
    for (const option of methodConfig.options) {
        a = args.option(option.name, option.description);
    }
    a.command(methodConfig.method, methodConfig.description, (command, sub, options) => {
        const projectConfigPath = sub[0];
        if (!projectConfigPath) {
            console.log("请输入项目配置文件");
            process.exit(1);
        }


        const cwd = path.resolve(process.cwd(), path.dirname(projectConfigPath));
        const compiler = new EgretCompiler(cwd);
        const method = (compiler as any)[methodConfig.method] as Function;
        executeWithErrorHandling(
            method.call(compiler, options || {})
        );
    });

}

function executeWithErrorHandling(p: Promise<any>) {
    p.catch((e: { code: number | undefined; message: string; }) => {
        if (e.code) {
            process.stderr.write(e.message + '\n');
            process.exit(e.code);
        } else {
            throw e;
        }
    });
}

function parseProjectRoot(sub: string[]) {
    const result = sub[0] ? sub[0] : ".";
    if (!path.isAbsolute(result)) {
        return path.resolve(process.cwd(), result);
    }
    else {
        return result;
    }
}

const flags = args.parse(process.argv);