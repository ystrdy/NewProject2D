//@ts-check
const lib = require('../dist/');
const path = require("path");
const fs = require("fs");
const assert = require("assert");
const mock = require("mock-fs");
const { beforeEach, afterEach, describe, it } = require('mocha');
const os = require('os');

const fsData = {
    "/path/to/fake/dir": {
        "some-file.txt": "file content here",
        "empty-dir": {
            /** empty directory */
        }
    }
}

beforeEach(() => {
    mock(fsData);
});

afterEach(() => {
    mock.restore();
});

describe("index", () => {
    it("不存在的 engineName 会返回 null", () => {
        const result = lib.getEngineRoot('a/error/engine/name');
        assert.equal(result, null, 'result should be null');
    });

    it("没有 .egretpro 目录时，将自动创建", () => {
        const name = 'testEngine';
        const root = '/my/engine';
        lib.setEngineRoot(name, root);
        const cacheDirector = path.join(os.homedir(), '.egretpro');
        const result = fs.existsSync(cacheDirector);
        assert.equal(result, true, "result should be equal with true");
    });

    it("设置 root 后可以读取出来，并且值保持不变", () => {
        const name = 'testEngine';
        const root = '/my/engine';
        lib.setEngineRoot(name, root);
        const newRoot = lib.getEngineRoot(name);
        assert.equal(root, newRoot, 'root should be equal with newRoot');
    });

    it("设置 root 后可以从文件系统中读取", () => {
        const cacheFileName = path.join(os.homedir(), '.egretpro', 'engines.json');

        const name = 'testEngine';
        const root = '/my/engine';
        lib.setEngineRoot(name, root);
        const content = fs.readFileSync(cacheFileName, 'utf-8');
        const data = JSON.parse(content);
        assert.equal(data[name], root, 'data[name] should be equal with root');
    });

    it("json 文件不存在时，读取 root 的值返回 null", () => {
        const result = lib.getEngineRoot("testEngine");
        assert.equal(result, null, "result should be equal with null");
    });

    it("json 文件错误时，读取 root 的值返回 null", () => {
        const name = 'testEngine';
        const root = '/my/engine';
        lib.setEngineRoot(name, root);
        const cacheFileName = path.join(os.homedir(), '.egretpro', 'engines.json');
        fs.writeFileSync(cacheFileName, "wrong json text", 'utf-8');
        const result = lib.getEngineRoot("testEngine");
        assert.equal(result, null, "result should be equal with null");
    });

    it("json 文件中已经存在 root 值，能正确读取", () => {
        const cacheDirector = path.join(os.homedir(), '.egretpro');
        if (!fs.existsSync(cacheDirector)) {
            fs.mkdirSync(cacheDirector);
        }
        const cacheFileName = path.join(os.homedir(), '.egretpro', 'engines.json');
        fs.writeFileSync(cacheFileName, `{"testEngine":"/my/engine"}`, 'utf-8');
        const result = lib.getEngineRoot("testEngine");
        assert.equal(result, "/my/engine", `result should be equal with string "/my/engine"`);
    });

    describe("root 必须是绝对路径", () => {
        it("传入相对路径，抛出异常", () => {
            assert.throws(() => {
                lib.setEngineRoot("rootName", "relative/root");
            });
        });

        it("传入空值，抛出异常", () => {
            assert.throws(() => {
                lib.setEngineRoot("rootName", "");
            });
        });
    });

    describe("获取所有 name 和 root 的值，返回一个数组", () => {
        it("返回的数组中元素是 name 和 path 两种属性构成的对象", () => {
            const name = 'testEngine1';
            const root = '/my/engine';
            lib.setEngineRoot(name, root);
            lib.setEngineRoot('testEngine2', '/my/engine');
            lib.setEngineRoot('testEngine3', '/my/engine');
            const result = lib.getEngineRoots();
            const array = [{ name: 'testEngine1', path: '/my/engine' }, { name: 'testEngine2', path: '/my/engine' }, { name: 'testEngine3', path: '/my/engine' }];
            const islengthEqual = result.length === array.length;
            assert.equal(islengthEqual, true, "length of result should be equal with array's");
            let isValueEqual = false;
            if (islengthEqual) {
                for (let i = 0; i < 3; i++) {
                    const resultKeys = [];
                    const resultValues = [];
                    for (const key in result[i]) {
                        resultKeys.push(key);
                        resultValues.push(result[i][key]);
                    }
                    const arrayKeys = [];
                    const arrayValues = [];
                    for (const key in array[i]) {
                        arrayKeys.push(key);
                        arrayValues.push(array[i][key]);
                    }
                    isValueEqual = resultKeys[0] === arrayKeys[0] && resultKeys[1] === arrayKeys[1];
                    if (!isValueEqual) {
                        break;
                    }
                    isValueEqual = resultValues[0] === arrayValues[0] && resultValues[1] === arrayValues[1];
                    if (!isValueEqual) {
                        break;
                    }
                }
            }
            assert.equal(isValueEqual, true, "values of result should be equal with array's");
        });

        it("没有数据时，返回空数组", () => {
            const result = lib.getEngineRoots();
            const length = result.length;
            assert.equal(length, 0, "length of result should be equal with 0");
        });

        it("json 文件不存在时，返回空数组", () => {
            const result = lib.getEngineRoots();
            const length = result.length;
            assert.equal(length, 0, "length of result should be equal with 0");
        });

        it("json 文件错误时，返回空数组", () => {
            const name = 'testEngine';
            const root = '/my/engine';
            lib.setEngineRoot(name, root);
            const cacheFileName = path.join(os.homedir(), '.egretpro', 'engines.json');
            fs.writeFileSync(cacheFileName, "wrong json text", 'utf-8');
            const result = lib.getEngineRoots();
            const length = result.length;
            assert.equal(length, 0, "length of result should be equal with 0");
        });
    });

});